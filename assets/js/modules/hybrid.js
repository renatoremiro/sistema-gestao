/* ========== üîÑ SISTEMA DE SINCRONIZA√á√ÉO H√çBRIDA v6.6.0 ========== */

const HybridSync = {
    // ‚úÖ CONFIGURA√á√ïES
    config: {
        versao: '6.6.0',
        autoSyncEnabled: true,
        conflictDetectionEnabled: true,
        logLevel: 'info', // 'debug', 'info', 'warn', 'error'
        syncDelay: 100, // ms para evitar loops
        maxConflictsShow: 5,
        indicadoresVisuais: {
            sincronizado: 'üîÑ',
            conflito: '‚ö†Ô∏è',
            promovido: '‚¨ÜÔ∏è',
            origem: 'üìÖ'
        }
    },

    // ‚úÖ ESTADO INTERNO
    state: {
        inicializado: false,
        ultimaSync: null,
        eventosObservados: new Set(),
        tarefasObservadas: new Set(),
        conflitosDetectados: [],
        syncInProgress: false,
        estatisticas: {
            eventosSync: 0,
            tarefasPromovidas: 0,
            conflitosResolvidos: 0
        }
    },

    // ‚úÖ INICIALIZA√á√ÉO DO M√ìDULO
    inicializar() {
        try {
            console.log('üîÑ Inicializando Sistema de Sincroniza√ß√£o H√≠brida v6.6.0...');

            // Verificar depend√™ncias
            if (!this._verificarDependencias()) {
                throw new Error('Depend√™ncias n√£o satisfeitas');
            }

            // Configurar listeners autom√°ticos
            this._configurarListeners();

            // Executar sincroniza√ß√£o inicial
            this._executarSyncInicial();

            // Configurar verifica√ß√£o de conflitos
            this._iniciarMonitoramentoConflitos();

            this.state.inicializado = true;
            this.state.ultimaSync = new Date();

            console.log('‚úÖ Sistema de Sincroniza√ß√£o H√≠brida inicializado com sucesso!');
            
            if (typeof Notifications !== 'undefined') {
                Notifications.success('Sistema h√≠brido v6.6.0 - Sincroniza√ß√£o ativada!');
            }

            return true;

        } catch (error) {
            console.error('‚ùå Erro ao inicializar sincroniza√ß√£o h√≠brida:', error);
            if (typeof Notifications !== 'undefined') {
                Notifications.error(`Erro na sincroniza√ß√£o: ${error.message}`);
            }
            return false;
        }
    },

    // ‚úÖ SINCRONIZA√á√ÉO AUTOM√ÅTICA: EVENTOS ‚Üí TAREFAS PESSOAIS
    sincronizarEventosParaTarefas() {
        try {
            if (this.state.syncInProgress) {
                console.log('‚è≥ Sincroniza√ß√£o j√° em andamento...');
                return;
            }

            this.state.syncInProgress = true;
            console.log('üîÑ Iniciando sincroniza√ß√£o Events ‚Üí Tasks...');

            // Verificar se dados est√£o dispon√≠veis
            if (!App.dados?.eventos || !App.dados?.tarefas) {
                console.warn('‚ö†Ô∏è Dados n√£o dispon√≠veis para sincroniza√ß√£o');
                return;
            }

            let eventosProcessados = 0;
            let tarefasCriadas = 0;

            // Processar cada evento
            App.dados.eventos.forEach(evento => {
                if (evento.pessoas && Array.isArray(evento.pessoas)) {
                    evento.pessoas.forEach(participante => {
                        // Verificar se j√° existe tarefa sincronizada para este evento/participante
                        const tarefaExistente = this._buscarTarefaSincronizada(evento.id, participante);
                        
                        if (!tarefaExistente) {
                            // Criar nova tarefa pessoal sincronizada
                            const novaTarefa = this._criarTarefaSincronizada(evento, participante);
                            
                            if (novaTarefa) {
                                App.dados.tarefas.push(novaTarefa);
                                tarefasCriadas++;
                                this.state.estatisticas.eventosSync++;
                                
                                console.log(`‚úÖ Tarefa criada para ${participante}: ${evento.titulo}`);
                            }
                        }
                    });
                }
                eventosProcessados++;
            });

            // Salvar dados se houve mudan√ßas
            if (tarefasCriadas > 0) {
                this._salvarDados();
                this._atualizarInterface();
                
                if (typeof Notifications !== 'undefined') {
                    Notifications.success(`üîÑ ${tarefasCriadas} tarefa(s) sincronizada(s) automaticamente`);
                }
            }

            console.log(`‚úÖ Sincroniza√ß√£o conclu√≠da: ${eventosProcessados} eventos processados, ${tarefasCriadas} tarefas criadas`);

        } catch (error) {
            console.error('‚ùå Erro na sincroniza√ß√£o Events ‚Üí Tasks:', error);
            if (typeof Notifications !== 'undefined') {
                Notifications.error('Erro na sincroniza√ß√£o autom√°tica');
            }
        } finally {
            this.state.syncInProgress = false;
        }
    },

    // ‚úÖ PROMO√á√ÉO MANUAL: TAREFAS ‚Üí EVENTOS
    promoverTarefaParaEvento(tarefaId) {
        try {
            console.log('‚¨ÜÔ∏è Promovendo tarefa para evento:', tarefaId);

            // Buscar tarefa
            const tarefa = App.dados?.tarefas?.find(t => t.id == tarefaId);
            if (!tarefa) {
                throw new Error('Tarefa n√£o encontrada');
            }

            // Verificar se j√° foi promovida
            if (tarefa.eventoPromovido) {
                if (typeof Notifications !== 'undefined') {
                    Notifications.warning('Esta tarefa j√° foi promovida para evento');
                }
                return false;
            }

            // Criar evento baseado na tarefa
            const novoEvento = this._criarEventoPromovido(tarefa);
            
            if (!novoEvento) {
                throw new Error('Erro ao criar evento promovido');
            }

            // Adicionar evento aos dados
            if (!App.dados.eventos) {
                App.dados.eventos = [];
            }
            App.dados.eventos.push(novoEvento);

            // Marcar tarefa como promovida (mas mant√™-la)
            tarefa.eventoPromovido = novoEvento.id;
            tarefa.ultimaAtualizacao = new Date().toISOString();

            // Salvar dados
            this._salvarDados();
            this._atualizarInterface();

            // Atualizar estat√≠sticas
            this.state.estatisticas.tarefasPromovidas++;

            console.log(`‚úÖ Tarefa "${tarefa.titulo}" promovida para evento ID: ${novoEvento.id}`);
            
            if (typeof Notifications !== 'undefined') {
                Notifications.success(`‚¨ÜÔ∏è Tarefa promovida para evento: "${tarefa.titulo}"`);
            }

            return novoEvento;

        } catch (error) {
            console.error('‚ùå Erro ao promover tarefa:', error);
            if (typeof Notifications !== 'undefined') {
                Notifications.error(`Erro na promo√ß√£o: ${error.message}`);
            }
            return false;
        }
    },

    // ‚úÖ DETECTAR E EXIBIR CONFLITOS
    detectarConflitos() {
        try {
            if (!this.config.conflictDetectionEnabled) {
                return [];
            }

            console.log('üîç Detectando conflitos de agenda...');

            const conflitos = [];
            const eventosETarefas = this._obterEventosETarefasComHorario();

            // Agrupar por pessoa e data
            const agendaPorPessoa = {};

            eventosETarefas.forEach(item => {
                const pessoas = item.tipo === 'evento' ? item.pessoas : [item.responsavel];
                
                pessoas.forEach(pessoa => {
                    if (!agendaPorPessoa[pessoa]) {
                        agendaPorPessoa[pessoa] = {};
                    }
                    
                    const data = item.data || item.dataInicio;
                    if (!data) return;
                    
                    if (!agendaPorPessoa[pessoa][data]) {
                        agendaPorPessoa[pessoa][data] = [];
                    }
                    
                    agendaPorPessoa[pessoa][data].push(item);
                });
            });

            // Detectar sobreposi√ß√µes
            Object.entries(agendaPorPessoa).forEach(([pessoa, agenda]) => {
                Object.entries(agenda).forEach(([data, itens]) => {
                    if (itens.length > 1) {
                        // Verificar sobreposi√ß√µes de hor√°rio
                        const conflitosData = this._verificarSobreposicaoHorarios(itens, pessoa, data);
                        conflitos.push(...conflitosData);
                    }
                });
            });

            this.state.conflitosDetectados = conflitos;

            if (conflitos.length > 0) {
                console.log(`‚ö†Ô∏è ${conflitos.length} conflito(s) detectado(s)`);
                this._exibirIndicadoresConflitos(conflitos);
            }

            return conflitos;

        } catch (error) {
            console.error('‚ùå Erro ao detectar conflitos:', error);
            return [];
        }
    },

    // ‚úÖ OBTER ESTAT√çSTICAS DO SISTEMA
    obterEstatisticas() {
        return {
            ...this.state.estatisticas,
            inicializado: this.state.inicializado,
            ultimaSync: this.state.ultimaSync,
            conflitosAtivos: this.state.conflitosDetectados.length,
            eventosMonitorados: this.state.eventosObservados.size,
            tarefasMonitoradas: this.state.tarefasObservadas.size
        };
    },

    // ‚úÖ OBTER STATUS COMPLETO
    obterStatus() {
        const stats = this.obterEstatisticas();
        
        return {
            versao: this.config.versao,
            ativo: this.state.inicializado,
            autoSync: this.config.autoSyncEnabled,
            detectarConflitos: this.config.conflictDetectionEnabled,
            ultimaSync: this.state.ultimaSync?.toLocaleString('pt-BR'),
            estatisticas: stats,
            dependenciasOk: this._verificarDependencias(),
            integracoes: {
                Events: typeof Events !== 'undefined',
                Tasks: typeof Tasks !== 'undefined',
                Calendar: typeof Calendar !== 'undefined',
                PersonalAgenda: typeof PersonalAgenda !== 'undefined'
            }
        };
    },

    // === M√âTODOS PRIVADOS ===

    // ‚úÖ VERIFICAR DEPEND√äNCIAS
    _verificarDependencias() {
        const dependencias = [
            typeof App !== 'undefined' && App.dados,
            typeof Events !== 'undefined',
            typeof Tasks !== 'undefined'
        ];

        return dependencias.every(dep => dep);
    },

    // ‚úÖ CONFIGURAR LISTENERS AUTOM√ÅTICOS
    _configurarListeners() {
        console.log('üîß Configurando listeners de sincroniza√ß√£o...');

        // Listener para novos eventos (simulado - na implementa√ß√£o real seria no Events.js)
        this._configurarEventListeners();

        // Listener para mudan√ßas nos dados (simulado)
        if (typeof App !== 'undefined' && App.dados) {
            // Em uma implementa√ß√£o real, usar√≠amos Proxy ou observers
            console.log('üì° Listeners configurados para mudan√ßas nos dados');
        }
    },

    // ‚úÖ CONFIGURAR EVENT LISTENERS
    _configurarEventListeners() {
        // Interceptar cria√ß√£o de eventos
        if (typeof Events !== 'undefined' && Events.salvarEvento) {
            const originalSalvarEvento = Events.salvarEvento;
            Events.salvarEvento = async (dadosEvento) => {
                const resultado = await originalSalvarEvento.call(Events, dadosEvento);
                
                if (resultado && this.config.autoSyncEnabled) {
                    // Aguardar um pouco para evitar loops
                    setTimeout(() => {
                        this.sincronizarEventosParaTarefas();
                    }, this.config.syncDelay);
                }
                
                return resultado;
            };
        }

        // Interceptar cria√ß√£o de tarefas (adicionar bot√£o de promo√ß√£o)
        if (typeof Tasks !== 'undefined') {
            console.log('üîó Integra√ß√£o com Tasks.js configurada');
        }
    },

    // ‚úÖ EXECUTAR SINCRONIZA√á√ÉO INICIAL
    _executarSyncInicial() {
        console.log('üîÑ Executando sincroniza√ß√£o inicial...');
        
        if (this.config.autoSyncEnabled) {
            // Aguardar um pouco para garantir que tudo est√° carregado
            setTimeout(() => {
                this.sincronizarEventosParaTarefas();
            }, 500);
        }
    },

    // ‚úÖ INICIAR MONITORAMENTO DE CONFLITOS
    _iniciarMonitoramentoConflitos() {
        if (this.config.conflictDetectionEnabled) {
            // Detectar conflitos a cada 30 segundos
            setInterval(() => {
                this.detectarConflitos();
            }, 30000);
            
            console.log('‚ö†Ô∏è Monitoramento de conflitos ativado');
        }
    },

    // ‚úÖ BUSCAR TAREFA SINCRONIZADA
    _buscarTarefaSincronizada(eventoId, participante) {
        if (!App.dados?.tarefas) return null;
        
        return App.dados.tarefas.find(tarefa => 
            tarefa.eventoOrigemId == eventoId && 
            tarefa.responsavel === participante &&
            tarefa.sincronizada === true
        );
    },

    // ‚úÖ CRIAR TAREFA SINCRONIZADA
    _criarTarefaSincronizada(evento, participante) {
        try {
            const novaTarefa = {
                id: Date.now() + Math.random(), // ID √∫nico
                titulo: `${this.config.indicadoresVisuais.origem} ${evento.titulo}`,
                tipo: 'equipe',
                prioridade: this._mapearPrioridadePorTipo(evento.tipo),
                status: 'agendado',
                responsavel: participante,
                dataInicio: evento.data,
                dataFim: evento.data,
                horario: evento.horarioInicio,
                horarioFim: evento.horarioFim,
                descricao: evento.descricao || `Participa√ß√£o no evento: ${evento.titulo}`,
                // Campos de sincroniza√ß√£o
                sincronizada: true,
                eventoOrigemId: evento.id,
                tipoSincronizacao: 'evento_para_tarefa',
                dataSincronizacao: new Date().toISOString(),
                progresso: 0,
                dataCriacao: new Date().toISOString(),
                ultimaAtualizacao: new Date().toISOString()
            };

            return novaTarefa;

        } catch (error) {
            console.error('‚ùå Erro ao criar tarefa sincronizada:', error);
            return null;
        }
    },

    // ‚úÖ CRIAR EVENTO PROMOVIDO
    _criarEventoPromovido(tarefa) {
        try {
            // Determinar participantes
            let participantes = [tarefa.responsavel];
            
            // Se tarefa tem participantes marcados, usar eles
            if (tarefa.participantes && Array.isArray(tarefa.participantes)) {
                participantes = tarefa.participantes;
            } else if (tarefa.equipe && Array.isArray(tarefa.equipe)) {
                participantes = tarefa.equipe;
            }

            const novoEvento = {
                id: Date.now() + Math.random(), // ID √∫nico
                titulo: `${this.config.indicadoresVisuais.promovido} ${tarefa.titulo}`,
                tipo: this._mapearTipoParaEvento(tarefa.tipo),
                data: tarefa.dataFim || tarefa.dataInicio || new Date().toISOString().split('T')[0],
                horarioInicio: tarefa.horario || '09:00',
                horarioFim: tarefa.horarioFim || this._calcularHorarioFim(tarefa.horario, tarefa.estimativa),
                pessoas: participantes,
                descricao: tarefa.descricao || `Evento criado a partir da tarefa: ${tarefa.titulo}`,
                local: tarefa.local || '',
                status: 'agendado',
                // Campos de sincroniza√ß√£o
                promovido: true,
                tarefaOrigemId: tarefa.id,
                tipoSincronizacao: 'tarefa_para_evento',
                dataPromocao: new Date().toISOString(),
                dataCriacao: new Date().toISOString(),
                ultimaAtualizacao: new Date().toISOString()
            };

            return novoEvento;

        } catch (error) {
            console.error('‚ùå Erro ao criar evento promovido:', error);
            return null;
        }
    },

    // ‚úÖ MAPEAR PRIORIDADE POR TIPO DE EVENTO
    _mapearPrioridadePorTipo(tipoEvento) {
        const mapeamento = {
            'reuniao': 'media',
            'entrega': 'alta',
            'prazo': 'critica',
            'marco': 'alta',
            'outro': 'baixa'
        };
        
        return mapeamento[tipoEvento] || 'media';
    },

    // ‚úÖ MAPEAR TIPO DE TAREFA PARA TIPO DE EVENTO
    _mapearTipoParaEvento(tipoTarefa) {
        const mapeamento = {
            'pessoal': 'outro',
            'equipe': 'reuniao',
            'projeto': 'marco',
            'urgente': 'prazo',
            'rotina': 'outro'
        };
        
        return mapeamento[tipoTarefa] || 'outro';
    },

    // ‚úÖ CALCULAR HOR√ÅRIO DE FIM
    _calcularHorarioFim(horarioInicio, estimativaMinutos) {
        if (!horarioInicio) return '10:00';
        
        try {
            const [hora, minuto] = horarioInicio.split(':').map(Number);
            const estimativa = estimativaMinutos || 60; // default 1h
            
            const totalMinutos = hora * 60 + minuto + estimativa;
            const horaFim = Math.floor(totalMinutos / 60);
            const minutoFim = totalMinutos % 60;
            
            return `${String(horaFim).padStart(2, '0')}:${String(minutoFim).padStart(2, '0')}`;
            
        } catch (error) {
            return '10:00'; // fallback
        }
    },

    // ‚úÖ OBTER EVENTOS E TAREFAS COM HOR√ÅRIO
    _obterEventosETarefasComHorario() {
        const itens = [];
        
        // Adicionar eventos
        if (App.dados?.eventos) {
            App.dados.eventos.forEach(evento => {
                if (evento.horarioInicio) {
                    itens.push({
                        ...evento,
                        tipo: 'evento',
                        horario: evento.horarioInicio
                    });
                }
            });
        }
        
        // Adicionar tarefas com hor√°rio
        if (App.dados?.tarefas) {
            App.dados.tarefas.forEach(tarefa => {
                if (tarefa.horario || tarefa.dataInicio) {
                    itens.push({
                        ...tarefa,
                        tipo: 'tarefa',
                        data: tarefa.dataInicio || tarefa.dataFim
                    });
                }
            });
        }
        
        return itens;
    },

    // ‚úÖ VERIFICAR SOBREPOSI√á√ÉO DE HOR√ÅRIOS
    _verificarSobreposicaoHorarios(itens, pessoa, data) {
        const conflitos = [];
        
        for (let i = 0; i < itens.length; i++) {
            for (let j = i + 1; j < itens.length; j++) {
                const item1 = itens[i];
                const item2 = itens[j];
                
                if (this._horariosSeSerempem(item1, item2)) {
                    conflitos.push({
                        tipo: 'sobreposicao_horario',
                        pessoa: pessoa,
                        data: data,
                        item1: item1,
                        item2: item2,
                        gravidade: this._calcularGravidadeConflito(item1, item2),
                        detectedAt: new Date()
                    });
                }
            }
        }
        
        return conflitos;
    },

    // ‚úÖ VERIFICAR SE HOR√ÅRIOS SE SOBREP√ïEM
    _horariosSeSerempem(item1, item2) {
        try {
            const horario1Inicio = item1.horario || item1.horarioInicio;
            const horario1Fim = item1.horarioFim || this._calcularHorarioFim(horario1Inicio, item1.estimativa);
            
            const horario2Inicio = item2.horario || item2.horarioInicio;
            const horario2Fim = item2.horarioFim || this._calcularHorarioFim(horario2Inicio, item2.estimativa);
            
            if (!horario1Inicio || !horario2Inicio) return false;
            
            const inicio1 = this._converterHorarioParaMinutos(horario1Inicio);
            const fim1 = this._converterHorarioParaMinutos(horario1Fim);
            const inicio2 = this._converterHorarioParaMinutos(horario2Inicio);
            const fim2 = this._converterHorarioParaMinutos(horario2Fim);
            
            return (inicio1 < fim2 && inicio2 < fim1);
            
        } catch (error) {
            return false;
        }
    },

    // ‚úÖ CONVERTER HOR√ÅRIO PARA MINUTOS
    _converterHorarioParaMinutos(horario) {
        const [hora, minuto] = horario.split(':').map(Number);
        return hora * 60 + minuto;
    },

    // ‚úÖ CALCULAR GRAVIDADE DO CONFLITO
    _calcularGravidadeConflito(item1, item2) {
        let gravidade = 1;
        
        // Evento vs evento = mais grave
        if (item1.tipo === 'evento' && item2.tipo === 'evento') {
            gravidade += 2;
        }
        
        // Prioridades altas = mais grave
        if (item1.prioridade === 'critica' || item2.prioridade === 'critica') {
            gravidade += 2;
        } else if (item1.prioridade === 'alta' || item2.prioridade === 'alta') {
            gravidade += 1;
        }
        
        return Math.min(gravidade, 5); // m√°ximo 5
    },

    // ‚úÖ EXIBIR INDICADORES DE CONFLITOS
    _exibirIndicadoresConflitos(conflitos) {
        if (conflitos.length === 0) return;
        
        // Mostrar at√© 5 conflitos mais graves
        const conflitosParaMostrar = conflitos
            .sort((a, b) => b.gravidade - a.gravidade)
            .slice(0, this.config.maxConflictsShow);
        
        conflitosParaMostrar.forEach(conflito => {
            const mensagem = `‚ö†Ô∏è Conflito: ${conflito.pessoa} tem sobreposi√ß√£o em ${new Date(conflito.data).toLocaleDateString('pt-BR')}`;
            
            if (typeof Notifications !== 'undefined') {
                Notifications.warning(mensagem);
            }
            
            console.log(`‚ö†Ô∏è CONFLITO DETECTADO:`);
            console.log(`   Pessoa: ${conflito.pessoa}`);
            console.log(`   Data: ${conflito.data}`);
            console.log(`   Item 1: ${conflito.item1.titulo} (${conflito.item1.horario || conflito.item1.horarioInicio})`);
            console.log(`   Item 2: ${conflito.item2.titulo} (${conflito.item2.horario || conflito.item2.horarioInicio})`);
            console.log(`   Gravidade: ${conflito.gravidade}/5`);
        });
    },

    // ‚úÖ SALVAR DADOS
    _salvarDados() {
        try {
            if (typeof Persistence !== 'undefined' && typeof Persistence.salvarDadosCritico === 'function') {
                Persistence.salvarDadosCritico();
            }
        } catch (error) {
            console.error('‚ùå Erro ao salvar dados:', error);
        }
    },

    // ‚úÖ ATUALIZAR INTERFACE
    _atualizarInterface() {
        try {
            // Atualizar calend√°rio
            if (typeof Calendar !== 'undefined' && typeof Calendar.gerar === 'function') {
                Calendar.gerar();
            }
            
            // Atualizar agenda pessoal se estiver aberta
            if (typeof PersonalAgenda !== 'undefined' && PersonalAgenda.state?.modalAberto) {
                if (typeof PersonalAgenda._atualizarDados === 'function') {
                    PersonalAgenda._atualizarDados();
                }
            }
        } catch (error) {
            console.error('‚ùå Erro ao atualizar interface:', error);
        }
    }
};

// ‚úÖ EXTENS√ÉO PARA TASKS.JS - BOT√ÉO DE PROMO√á√ÉO
const TasksHybridExtension = {
    // Adicionar bot√£o de promo√ß√£o a todas as tarefas
    adicionarBotaoPromocao(tarefaId, container) {
        if (!container) return;
        
        const tarefa = App.dados?.tarefas?.find(t => t.id == tarefaId);
        if (!tarefa) return;
        
        // N√£o mostrar se j√° foi promovida
        if (tarefa.eventoPromovido) {
            return;
        }
        
        const botaoPromover = document.createElement('button');
        botaoPromover.className = 'btn btn-success btn-sm';
        botaoPromover.style.cssText = 'font-size: 10px; padding: 2px 6px; margin-left: 4px;';
        botaoPromover.innerHTML = '‚¨ÜÔ∏è Promover para Evento';
        botaoPromover.title = 'Promover esta tarefa para evento do calend√°rio principal';
        
        botaoPromover.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            
            const confirmacao = confirm(
                `Promover tarefa para evento?\n\n` +
                `üìù ${tarefa.titulo}\n\n` +
                `Isso criar√° um evento no calend√°rio principal.`
            );
            
            if (confirmacao) {
                HybridSync.promoverTarefaParaEvento(tarefaId);
            }
        });
        
        container.appendChild(botaoPromover);
    }
};

// ‚úÖ EXTENS√ÉO PARA PERSONAL AGENDA - INTEGRA√á√ÉO DE BOT√ïES
const PersonalAgendaHybridExtension = {
    // Adicionar bot√µes de promo√ß√£o aos renderizadores
    integrarBotoesPromocao() {
        // Esta fun√ß√£o seria integrada ao PersonalAgenda._renderizarTarefaMini
        console.log('üîó Integra√ß√£o com PersonalAgenda configurada');
    }
};

// ‚úÖ FUN√á√ïES GLOBAIS PARA DEBUG E CONTROLE
window.HybridSync_Debug = {
    status: () => HybridSync.obterStatus(),
    estatisticas: () => HybridSync.obterEstatisticas(),
    conflitos: () => HybridSync.detectarConflitos(),
    sincronizar: () => HybridSync.sincronizarEventosParaTarefas(),
    promover: (tarefaId) => HybridSync.promoverTarefaParaEvento(tarefaId),
    inicializar: () => HybridSync.inicializar(),
    
    // Fun√ß√µes de teste
    criarEventoTeste: () => {
        const eventoTeste = {
            id: Date.now(),
            titulo: 'Reuni√£o de Teste Sync',
            tipo: 'reuniao',
            data: new Date().toISOString().split('T')[0],
            horarioInicio: '14:00',
            horarioFim: '15:00',
            pessoas: ['Isabella', 'Lara', 'Eduardo'],
            descricao: 'Evento de teste para sincroniza√ß√£o'
        };
        
        if (!App.dados.eventos) App.dados.eventos = [];
        App.dados.eventos.push(eventoTeste);
        
        console.log('‚úÖ Evento de teste criado:', eventoTeste);
        HybridSync.sincronizarEventosParaTarefas();
        
        return eventoTeste;
    },
    
    criarTarefaTeste: () => {
        const tarefaTeste = {
            id: Date.now(),
            titulo: 'Tarefa de Teste para Promo√ß√£o',
            tipo: 'projeto',
            prioridade: 'alta',
            status: 'pendente',
            responsavel: 'Isabella',
            dataInicio: new Date().toISOString().split('T')[0],
            estimativa: 90,
            participantes: ['Isabella', 'Eduardo', 'Beto'],
            descricao: 'Tarefa de teste para promo√ß√£o a evento'
        };
        
        if (!App.dados.tarefas) App.dados.tarefas = [];
        App.dados.tarefas.push(tarefaTeste);
        
        console.log('‚úÖ Tarefa de teste criada:', tarefaTeste);
        
        return tarefaTeste;
    }
};

// ‚úÖ AUTO-INICIALIZA√á√ÉO
document.addEventListener('DOMContentLoaded', () => {
    // Aguardar outros m√≥dulos carregarem
    setTimeout(() => {
        if (typeof App !== 'undefined' && App.dados) {
            HybridSync.inicializar();
        }
    }, 2000);
});

// ‚úÖ LOG DE CARREGAMENTO
console.log('üîÑ Sistema de Sincroniza√ß√£o H√≠brida v6.6.0 carregado!');
console.log('üéØ Funcionalidades: Auto-sync Events‚ÜíTasks, Promo√ß√£o Tasks‚ÜíEvents, Detec√ß√£o de Conflitos');
console.log('‚úÖ Integra√ß√£o: Events.js, Tasks.js, PersonalAgenda.js, Calendar.js');
console.log('üß™ Debug: HybridSync_Debug.status(), HybridSync_Debug.criarEventoTeste(), HybridSync_Debug.sincronizar()');
console.log('‚ö° Auto-inicializa√ß√£o: Aguardando 2 segundos ap√≥s DOMContentLoaded');
