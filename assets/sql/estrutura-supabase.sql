-- 🗄️ ESTRUTURA COMPLETA SUPABASE PARA SISTEMA BIAPO v8.13.0
-- Execute este SQL no Supabase SQL Editor
-- Data: 2025-07-16

-- 🧹 LIMPAR TABELAS EXISTENTES (se houver)
DROP TABLE IF EXISTS participantes CASCADE;
DROP TABLE IF EXISTS tarefas CASCADE;
DROP TABLE IF EXISTS eventos CASCADE;
DROP TABLE IF EXISTS usuarios CASCADE;

-- 💾 TABELA BACKUPS DO SISTEMA
CREATE TABLE backups_sistema (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    usuario_email VARCHAR(255) NOT NULL,
    dados JSONB NOT NULL,
    versao VARCHAR(50) DEFAULT '1.0-supabase',
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT now(),
    checksum VARCHAR(100),
    tamanho_kb INTEGER,
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 📊 ÍNDICES PARA BACKUPS
CREATE INDEX idx_backups_usuario_email ON backups_sistema(usuario_email);
CREATE INDEX idx_backups_timestamp ON backups_sistema(timestamp);
CREATE INDEX idx_backups_versao ON backups_sistema(versao);

-- 🔄 TRIGGER PARA CALCULAR TAMANHO
CREATE OR REPLACE FUNCTION calcular_tamanho_backup()
RETURNS TRIGGER AS $
BEGIN
    NEW.tamanho_kb = length(NEW.dados::text) / 1024;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_calcular_tamanho_backup
    BEFORE INSERT OR UPDATE ON backups_sistema
    FOR EACH ROW
    EXECUTE FUNCTION calcular_tamanho_backup();

-- 👥 TABELA USUARIOS
CREATE TABLE usuarios (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    nome VARCHAR(255) NOT NULL,
    perfil VARCHAR(50) DEFAULT 'usuario',
    admin BOOLEAN DEFAULT false,
    ativo BOOLEAN DEFAULT true,
    ultimo_acesso TIMESTAMP WITH TIME ZONE DEFAULT now(),
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT now(),
    atualizado_em TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 📅 TABELA EVENTOS
CREATE TABLE eventos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    titulo VARCHAR(500) NOT NULL,
    descricao TEXT,
    data DATE NOT NULL,
    hora_inicio TIME,
    hora_fim TIME,
    local VARCHAR(255),
    categoria VARCHAR(100) DEFAULT 'geral',
    prioridade VARCHAR(20) DEFAULT 'media',
    status VARCHAR(50) DEFAULT 'agendado',
    visibilidade VARCHAR(20) DEFAULT 'publica',
    cor VARCHAR(20) DEFAULT 'blue',
    criado_por BIGINT REFERENCES usuarios(id),
    responsavel BIGINT REFERENCES usuarios(id),
    observacoes TEXT,
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT now(),
    atualizado_em TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 📋 TABELA TAREFAS
CREATE TABLE tarefas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    titulo VARCHAR(500) NOT NULL,
    descricao TEXT,
    data_inicio DATE,
    data_fim DATE,
    categoria VARCHAR(100) DEFAULT 'geral',
    prioridade VARCHAR(20) DEFAULT 'media',
    status VARCHAR(50) DEFAULT 'pendente',
    progresso INTEGER DEFAULT 0 CHECK (progresso >= 0 AND progresso <= 100),
    tipo VARCHAR(50) DEFAULT 'tarefa',
    criado_por BIGINT REFERENCES usuarios(id),
    responsavel BIGINT REFERENCES usuarios(id),
    observacoes TEXT,
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT now(),
    atualizado_em TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 👥 TABELA PARTICIPANTES (RELAÇÃO MUITOS-PARA-MUITOS)
CREATE TABLE participantes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    evento_id BIGINT REFERENCES eventos(id) ON DELETE CASCADE,
    tarefa_id BIGINT REFERENCES tarefas(id) ON DELETE CASCADE,
    usuario_id BIGINT REFERENCES usuarios(id) ON DELETE CASCADE,
    papel VARCHAR(50) DEFAULT 'participante',
    confirmado BOOLEAN DEFAULT false,
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 📊 ÍNDICES PARA PERFORMANCE
CREATE INDEX idx_eventos_data ON eventos(data);
CREATE INDEX idx_eventos_criado_por ON eventos(criado_por);
CREATE INDEX idx_eventos_responsavel ON eventos(responsavel);
CREATE INDEX idx_eventos_categoria ON eventos(categoria);
CREATE INDEX idx_eventos_status ON eventos(status);
CREATE INDEX idx_eventos_visibilidade ON eventos(visibilidade);

CREATE INDEX idx_tarefas_data_inicio ON tarefas(data_inicio);
CREATE INDEX idx_tarefas_data_fim ON tarefas(data_fim);
CREATE INDEX idx_tarefas_criado_por ON tarefas(criado_por);
CREATE INDEX idx_tarefas_responsavel ON tarefas(responsavel);
CREATE INDEX idx_tarefas_categoria ON tarefas(categoria);
CREATE INDEX idx_tarefas_status ON tarefas(status);

CREATE INDEX idx_participantes_evento_id ON participantes(evento_id);
CREATE INDEX idx_participantes_tarefa_id ON participantes(tarefa_id);
CREATE INDEX idx_participantes_usuario_id ON participantes(usuario_id);

CREATE INDEX idx_usuarios_email ON usuarios(email);
CREATE INDEX idx_usuarios_perfil ON usuarios(perfil);

-- 🔄 TRIGGERS PARA ATUALIZAR TIMESTAMP
CREATE OR REPLACE FUNCTION update_atualizado_em()
RETURNS TRIGGER AS $$
BEGIN
    NEW.atualizado_em = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_usuarios_atualizado_em
    BEFORE UPDATE ON usuarios
    FOR EACH ROW
    EXECUTE FUNCTION update_atualizado_em();

CREATE TRIGGER trigger_eventos_atualizado_em
    BEFORE UPDATE ON eventos
    FOR EACH ROW
    EXECUTE FUNCTION update_atualizado_em();

CREATE TRIGGER trigger_tarefas_atualizado_em
    BEFORE UPDATE ON tarefas
    FOR EACH ROW
    EXECUTE FUNCTION update_atualizado_em();

-- 📊 VIEWS PARA DADOS COMPLETOS
CREATE VIEW eventos_completos AS
SELECT 
    e.*,
    uc.nome as criador_nome,
    uc.email as criador_email,
    ur.nome as responsavel_nome,
    ur.email as responsavel_email,
    COALESCE(p.participantes_count, 0) as total_participantes
FROM eventos e
LEFT JOIN usuarios uc ON e.criado_por = uc.id
LEFT JOIN usuarios ur ON e.responsavel = ur.id
LEFT JOIN (
    SELECT evento_id, COUNT(*) as participantes_count
    FROM participantes 
    WHERE evento_id IS NOT NULL
    GROUP BY evento_id
) p ON e.id = p.evento_id;

CREATE VIEW tarefas_completas AS
SELECT 
    t.*,
    uc.nome as criador_nome,
    uc.email as criador_email,
    ur.nome as responsavel_nome,
    ur.email as responsavel_email,
    COALESCE(p.participantes_count, 0) as total_participantes
FROM tarefas t
LEFT JOIN usuarios uc ON t.criado_por = uc.id
LEFT JOIN usuarios ur ON t.responsavel = ur.id
LEFT JOIN (
    SELECT tarefa_id, COUNT(*) as participantes_count
    FROM participantes 
    WHERE tarefa_id IS NOT NULL
    GROUP BY tarefa_id
) p ON t.id = p.tarefa_id;

-- 👤 INSERIR USUÁRIO ADMIN PADRÃO
INSERT INTO usuarios (email, nome, perfil, admin) VALUES
('renatoremiro@biapo.com.br', 'Renato Remiro', 'admin', true)
ON CONFLICT (email) DO NOTHING;

-- 📊 DADOS DE EXEMPLO PARA TESTE
INSERT INTO eventos (titulo, descricao, data, hora_inicio, categoria, criado_por, responsavel)
SELECT 
    'Reunião de Equipe', 
    'Reunião semanal da equipe', 
    CURRENT_DATE + 1, 
    '09:00', 
    'reuniao',
    u.id,
    u.id
FROM usuarios u WHERE u.email = 'renatoremiro@biapo.com.br';

INSERT INTO tarefas (titulo, descricao, data_inicio, categoria, criado_por, responsavel)
SELECT 
    'Preparar apresentação', 
    'Preparar slides para reunião', 
    CURRENT_DATE, 
    'projeto',
    u.id,
    u.id
FROM usuarios u WHERE u.email = 'renatoremiro@biapo.com.br';

-- 🔐 CONFIGURAR RLS (ROW LEVEL SECURITY) - OPCIONAL
-- ALTER TABLE usuarios ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE eventos ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE tarefas ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE participantes ENABLE ROW LEVEL SECURITY;

-- ✅ VERIFICAR ESTRUTURA CRIADA
SELECT 
    'Usuários' as tabela, COUNT(*) as registros 
FROM usuarios
UNION ALL
SELECT 
    'Eventos' as tabela, COUNT(*) as registros 
FROM eventos
UNION ALL
SELECT 
    'Tarefas' as tabela, COUNT(*) as registros 
FROM tarefas
UNION ALL
SELECT 
    'Participantes' as tabela, COUNT(*) as registros 
FROM participantes;

-- 🎉 SUCESSO!
SELECT '🚀 ESTRUTURA SUPABASE CRIADA COM SUCESSO!' as resultado;